<!DOCTYPE html>
<html>
	<head>
		<script src='http://d3js.org/d3.v3.min.js'></script>
		<style>
			
			body
			{
				padding:0;
				margin:0;
			}
			input#ins
			{
				width: 50px;
				font-size: 21.5px;
			}
			button
			{
				font-size: 15px;
				vertical-align: top;
				padding-top:5px;
				padding-bottom:5px;
			}
			svg
			{
				padding:0;
				margin:0;
				border-right: 1px solid black;
				border-bottom: 1px solid black;
			}
			.node {
				 fill: #CCFFCC;
				 stroke: #dadada;
				 stroke-width: 2px;
			}
			.activeNode {
				stroke: blue;
			}
			.minNode {
				fill : yellow;
			}
			.deletedNode{
				fill : #F99;
			}
			.link {
				 stroke: #777;
				 stroke-width: 2px;
			}
			text
			{
				font-size: 16px;
			}
			
			.cell
			{
				fill: lightgreen;
				stroke-width: 0px;
			}
			.activeCell
			{
				fill: green;
				fill: #FFA500;
			}			
			div.rightblock
			{
				display:inline-block;
				vertical-align: top;
				padding: 10px;
				margin-right:-15px;
			}
			span.error
			{
				font-size:16px;
				color:red;
				display:inline-block;
				margin-bottom: 10px;
			}
			span.result
			{
				display:inline-block; 
				width:40px; 
				background-color: bisque;
				font-size:20px;
				padding-left: 5px;
			}
			span.curop
			{
				font-size: 17px;
				vertical-align: top;
				display:inline-block;
				margin: 10px;
			}
			span.operation
			{
				background-color: lightblue;
			}
			div
			{
				display:inline-block;
			}
			div#oper
			{
				font-size: 17px;
				overflow-y: scroll;
				margin:10px;
				margin-left:0px;
				max-height: 230px;
				display: inline-block;
				
			}
   	</style>
	</head>
	<body>
		<script>
			var d = document;
			var toInsert = [];
			var toMove = [];
			var delta;
			var needFinDelMin = false;
			var isauto = true;
			var isanim = false;
			var result;
			var isauto = true;
			var ismoving = false;
			var issecond = false;
			
			function getDelta(rank)
			{
				if (rank == 0) return svg.HOR_DIST;
				if (rank == 1) return 2 * svg.HOR_DIST;
				return 3 * getDelta(rank - 1);
			}
			
			function getFirstX(rank)
			{
				var ans = svg.START_X;
				for (var currank = thickHeap._maxRank; currank >= rank; currank--)
				{
					var pointer = thickHeap._rootCounter[currank].listPointer;
					if (pointer == null) continue;
					while (pointer != null)
					{
						ans = svg.getNodeCoords(pointer.index).x + svg.HOR_DIST;
						pointer = pointer.right;
					}
				}
				return ans;
			}
			
			var svg = {
				layout_ : null,
				nodes_ : [],
				edges_ : [],
				rootnodes_ : [],
				op_queue : [], // {op : "", args:[]}
				NODE_RADIUS : 17,
				START_X : 40,
				START_Y : 96,
				HOR_DIST : 60,
				VER_DIST : 75,
				nextRank : 0,
				DELAY : 10,
				nextX : 50,
				moveNodes : [], // {node:, x:, y:, stopx, stopy, moveFunc}

				setRootVal : function(index, value)
				{
					var el = svg.rootnodes_[index].children[3];
					var el1 = svg.rootnodes_[index].children[1];
					el1.classList.add("activeCell");
					el.textContent = value;
					setTimeout(function() {svg.nextAnimation(); el1.classList.remove("activeCell");}, 500);
				},
				
				getRootCoords : function(index)
				{
					var attr = this.rootnodes_[index].getAttribute("transform").substr(10).split(',');
					var x = parseInt(attr[0]), y = parseInt(attr[1]);
					return {x:x, y:y};
				},
				
				setRootCoords : function(index, x, y)
				{
					this.rootnodes_[index].setAttribute("transform", "translate(" + x + ", " + y + ")");
					while ((x + svg.NODE_RADIUS * 2) * layout.currentScale > +layout.getAttribute("width") ||
							 (y + svg.NODE_RADIUS * 2) * layout.currentScale > +layout.getAttribute("height"))
					{
						layout.currentScale = parseFloat(layout.currentScale) - 0.01
					}
				},
				
				// возвращает новую позицию
				updRootCoords : function(node, dx, dy)
				{
					var attr = node.getAttribute("transform").substr(10).split(',');
					var x = parseInt(attr[0]), y = parseInt(attr[1]);
					node.setAttribute("transform", "translate(" + (x + dx) + ", " + (y + dy) + ")");
					while ((x + svg.NODE_RADIUS * 2) * layout.currentScale > +layout.getAttribute("width") ||
							 (y + svg.NODE_RADIUS * 2) * layout.currentScale > +layout.getAttribute("height"))
					{
						layout.currentScale = parseFloat(layout.currentScale) - 0.01
					}
					return {x:x + dx, y:y + dy};
				},
				
				increaseRank : function()
				{
					var g = d.createElementNS("http://www.w3.org/2000/svg", 'g');
					
					
					var rect1 = d.createElementNS("http://www.w3.org/2000/svg","rect");
					rect1.classList.add("cell");
					rect1.setAttribute("width", "24");
					rect1.setAttribute("height", "24");
					
					var rect2 = d.createElementNS("http://www.w3.org/2000/svg","rect");
					rect2.classList.add("cell");
					rect2.setAttribute("width", "24");
					rect2.setAttribute("height", "24");
					rect2.setAttribute("y", "25");
					
					/*var rect3 = d.createElementNS("http://www.w3.org/2000/svg","rect");
					rect3.classList.add("cell");
					rect3.setAttribute("width", "24");
					rect3.setAttribute("height", "24");
					rect3.setAttribute("y", "50");*/
					
					var text1 = d.createElementNS("http://www.w3.org/2000/svg", "text");
					text1.setAttribute("x", "8");
					text1.setAttribute("y", "17");
					text1.textContent = svg.nextRank;
					
					var text2 = d.createElementNS("http://www.w3.org/2000/svg", "text");
					text2.setAttribute("x", "8");
					text2.setAttribute("y", "43");
					text2.textContent = "0";
					
					
					/*var text3 = d.createElementNS("http://www.w3.org/2000/svg", "text");
					text3.setAttribute("x", "8");
					text3.setAttribute("y", "71");
					text3.setAttribute("style", "font-size:26px");
					text3.textContent = "•";*/
					
					g.appendChild(rect1);
					g.appendChild(rect2);
					//g.appendChild(rect3);
					g.appendChild(text1);
					g.appendChild(text2);
					//g.appendChild(text3);
					g.style.opacity = 0;
					
					this.rootnodes_.push(g);
					
					this.setRootCoords(svg.nextRank, 90, 5);
					this.layout_.appendChild(g);
					svg.nextRank++;
					return svg.nextRank - 1;
				},
				
				moveRoot : function(node, dx, dy, isroot, func)
				{
					var cor = svg.updRootCoords(node, dx, dy);
					if (isroot)
					{
						if (func != null)
						{
							setTimeout(svg.moveStep, svg.DELAY);
						}
						return cor;
					}
				},
				
				
				moveFull : function(node, dx, dy, isroot, func)
				{
					var curcor = svg.updNodeCoords(node.index, dx, dy);
					if (node.tope != null)
					{
						svg.updEdgeCoords(node.tope, dx, dy);
					}
					if (node.righte != null)
					{
						svg.updEdgeCoords(node.righte, dx, dy);
					}
					
					if (node.right != null)
					{
						svg.moveFull(node.right, dx, dy, false);
					}
					if (node.leftChild != null)
					{
						svg.moveFull(node.leftChild, dx, dy, false);
					}
					
					if (isroot)
					{
						if (func != null)
						{
							setTimeout(svg.moveStep, svg.DELAY);
						}
						return curcor;
					}
				},
				
				moveTreeToDel : function(node, dx, dy, isroot, func)
				{
					var curcor = svg.updNodeCoords(node.index, dx, dy);
					if (node.tope != null)
					{
						svg.updEdgeCoords(node.tope, dx, dy);
					}
					if (node.righte != null)
					{
						svg.updEdgeCoords(node.righte, dx, dy);
					}
					
					if (node.right != null && isroot == false)
					{
						svg.moveTreeToDel(node.right, dx, dy, false);
					}
					if (node.leftChild != null)
					{
						svg.moveTreeToDel(node.leftChild, dx, dy, false);
					}
					
					if (isroot)
					{
						if (func != null)
						{
							setTimeout(svg.moveStep, svg.DELAY);
						}
						return curcor;
					}
				},
				
				// Перемещает все дерево на dx, dy.
				// По окончанию вызывает func
				// Возвращает новые коортинаты узла
				moveTreeFast : function(node, dx, dy, isroot, func)
				{
					if (isroot == false && (node == svg.moveNodes[0].node || 
												   node == svg.moveNodes[1].node ||
												   node == svg.moveNodes[2].node))
					{
						if (node.right != null)
						{
							svg.moveTreeFast(node.right, dx, dy, false);
						}
						return;
					}
					var curcor = svg.updNodeCoords(node.index, dx, dy);
					if (node.tope != null)
					{
						svg.updEdgeCoords(node.tope, dx, dy);
					}
					if (node.righte != null)
					{
						svg.updEdgeCoords(node.righte, dx, dy);
					}
					
					if (node.right != null && isroot == false)
					{
						svg.moveTreeFast(node.right, dx, dy, false);
					}
					if (node.leftChild != null)
					{
						svg.moveTreeFast(node.leftChild, dx, dy, false);
					}
					
					if (isroot)
					{
						if (func != null)
						{
							setTimeout(svg.moveStep, svg.DELAY);
						}
						return curcor;
					}
				},
				
				moveStep : function()
				{
					var wasfirst = false;
					for (var i = 0; i < svg.moveNodes.length; i++)
					{
						var el = svg.moveNodes[i];
						var newcor;
						if (el.x != el.stopx)
						{
							var dx = el.x < el.stopx ? 1 : -1;
							if (wasfirst == false)
							{
								newcor = el.moveFunc(el.node, dx, 0, true, svg.moveStep);
								wasfirst = true;
							}
							else
							{
								newcor = el.moveFunc(el.node, dx, 0, true, null);
							}
							el.x = newcor.x;
							el.y = newcor.y;
						}
						else if (el.y != el.stopy)
						{
							var dy = el.y < el.stopy ? 1 : -1;
							if (wasfirst == false)
							{
								newcor = el.moveFunc(el.node, 0, dy, true, svg.moveStep);
								wasfirst = true;
							}
							else
							{
								newcor = el.moveFunc(el.node, 0, dy, true, null);
							}
							el.x = newcor.x;
							el.y = newcor.y;
						}
					}
					if (wasfirst == false)
					{
						// добавляем нужные ребра после fastening
						if (svg.moveNodes.length && svg.moveNodes[0].moveFunc == svg.moveTreeFast && svg.moveNodes.length == 3)
						{
							var n1 = svg.moveNodes[0].node;
							var n2 = svg.moveNodes[1].node;
							var n3 = svg.moveNodes[2].node;
							svg.op_queue.unshift({op:"addedges", args:[n1, n2, n3]});
							svg.nextAnimation();
							return;
						}
						for (var i = 0; i < svg.moveNodes.length; i++)
						{
							if (svg.moveNodes[i].moveFunc != svg.moveRoot) svg.deactivateNode(svg.moveNodes[i].node.index);							
						}
						svg.nextAnimation();
					}
				},
				
				opacityStep : function(index, isnode, isdesc, func)
				{
					if (isdesc)
					{
						if (isnode)
						{
							if (svg.nodes_[index].style.opacity == 0)
							{
								svg.deactivateNode(index);
								if (func != null) func();
							}						
							else
							{
								svg.nodes_[index].style.opacity = +svg.nodes_[index].style.opacity - 0.02;
								setTimeout(svg.opacityStep, svg.DELAY, index, isnode, isdesc, func);
							}
						}
						else
						{
							if (svg.edges_[index].style.opacity == 0)
							{
								svg.deactivateEdge(index);
								if (func != null) func();
							}						
							else
							{
								svg.edges_[index].style.opacity = +svg.edges_[index].style.opacity - 0.02;
								setTimeout(svg.opacityStep, svg.DELAY, index, isnode, isdesc, func);
							}
						}
					}
					else
					{
						if (isnode)
						{
							if (svg.nodes_[index].style.opacity == 1)
							{
								svg.deactivateNode(index);
								if (func != null) func();
							}						
							else
							{
								svg.nodes_[index].style.opacity = +svg.nodes_[index].style.opacity + 0.02;
								setTimeout(svg.opacityStep, svg.DELAY, index, isnode, isdesc, func);
							}
						}
						else
						{
							if (svg.edges_[index].style.opacity == 1)
							{
								svg.deactivateEdge(index);
								if (func != null) func();
							}						
							else
							{
								svg.edges_[index].style.opacity = +svg.edges_[index].style.opacity + 0.02;
								setTimeout(svg.opacityStep, svg.DELAY, index, isnode, isdesc, func);
							}
						}
					}
				},
				
				activateEdge : function(index)
				{
					this.edges_[index].setAttribute("class", "link activeLink");
				},
				
				deactivateEdge : function(index)
				{
					this.edges_[index].setAttribute("class", "link");
				},
				
				activateNode : function(index)
				{
					this.nodes_[index].firstChild.classList.add("activeNode");// setAttribute("class", "node activeNode");
				},
				
				deactivateNode : function(index)
				{
					svg.nodes_[index].firstChild.classList.remove("activeNode");
				},
				
				createNode : function(value)
				{
					var g = d.createElementNS("http://www.w3.org/2000/svg", 'g');
					
					var circle = d.createElementNS("http://www.w3.org/2000/svg","circle");
					circle.setAttribute("class", "node");
					circle.setAttribute("r", this.NODE_RADIUS);
					g.appendChild(circle);
					g.style.opacity = 0;
					
					var text = d.createElementNS("http://www.w3.org/2000/svg","text");
					text.setAttribute("y", 5);
					text.setAttribute('text-anchor', "middle");
					text.textContent = value;
					g.appendChild(text);
					this.nodes_.push(g);
					
					this.setNodeCoords(this.nodes_.length - 1, this.nextX, this.START_Y);
					this.nextX += this.HOR_DIST;
					this.layout_.appendChild(g);
					return this.nodes_.length - 1;
				},
				
				createEdge(stind, finind, is2side)
				{
					var path = d.createElementNS("http://www.w3.org/2000/svg", 'path');
					
					var stcor = this.getNodeCoords(stind);
					var fincor = this.getNodeCoords(finind);
					
					path.setAttribute("class", "link");
					if (is2side)
					{
						path.setAttribute("style", "opacity:0; marker-end: url('#end-arrow'); marker-start: url('#start-arrow');");
					}
					else
					{
						path.setAttribute("style", "opacity:0; marker-end: url('#end-arrow');");
					}
					this.edges_.push(path);
					this.setEdgeCoords(this.edges_.length - 1, stcor.x, stcor.y, fincor.x, fincor.y);
					this.layout_.insertBefore(path, this.layout_.firstChild);
					return this.edges_.length - 1;
				},
				
				getNodeCoords : function(index)
				{
					var attr = this.nodes_[index].getAttribute("transform").substr(10).split(',');
					var x = parseInt(attr[0]), y = parseInt(attr[1]);
					return {x:x, y:y};
				},
				
				setNodeCoords : function(index, x, y)
				{
					this.nodes_[index].setAttribute("transform", "translate(" + x + ", " + y + ")");
					while ((x + svg.NODE_RADIUS * 2) * layout.currentScale > +layout.getAttribute("width") ||
							 (y + svg.NODE_RADIUS * 2) * layout.currentScale > +layout.getAttribute("height"))
					{
						layout.currentScale = parseFloat(layout.currentScale) - 0.01
					}
				},
				
				// возвращает новую позицию
				updNodeCoords : function(index, dx, dy)
				{
					var attr = this.nodes_[index].getAttribute("transform").substr(10).split(',');
					var x = parseInt(attr[0]), y = parseInt(attr[1]);
					this.nodes_[index].setAttribute("transform", "translate(" + (x + dx) + ", " + (y + dy) + ")");
					while ((x + svg.NODE_RADIUS * 2) * layout.currentScale > +layout.getAttribute("width") ||
							 (y + svg.NODE_RADIUS * 2) * layout.currentScale > +layout.getAttribute("height"))
					{
						layout.currentScale = parseFloat(layout.currentScale) - 0.01
					}
					return {x:x + dx, y:y + dy};
				},
								
				getEdgeCoords : function(index)
				{
					var attr = this.edges_[index].getAttribute("d").substr(1).split('L');
					attr[0] = attr[0].split(',');
					attr[1] = attr[1].split(',');
					var xs = parseInt(attr[0][0]), ys = parseInt(attr[0][1]);
					var xf = parseInt(attr[1][0]), yf = parseInt(attr[1][1]);
					return {xs:xs + dx, ys:ys + dy, xf:xf + dx, yf:yf + dy};
				},
				
				setEdgeCoords : function(index, xs, ys, xf, yf)
				{
					this.edges_[index].setAttribute("d", "M" + xs + "," + ys + "L" + xf + "," + yf);
				},
				
				// возвращает новую позицию
				updEdgeCoords : function(index, dx, dy)
				{
					var attr = this.edges_[index].getAttribute("d").substr(1).split('L');
					attr[0] = attr[0].split(',');
					attr[1] = attr[1].split(',');
					var xs = parseInt(attr[0][0]), ys = parseInt(attr[0][1]);
					var xf = parseInt(attr[1][0]), yf = parseInt(attr[1][1]);
					this.edges_[index].setAttribute("d", "M" + (xs + dx) + "," + (ys + dy) + "L" +
															  (xf + dx) + "," + (yf + dy));
					return {xs:xs + dx, ys:ys + dy, xf:xf + dx, yf:yf + dy};
				},
				
				nextAnimation : function()
				{
					if (isauto == false)
					{
						if (issecond == true)
						{
							ismoving = false;
							return;
						}
						else
						{
							ismoving = true;
							issecond = true;
						}
					}
					if (svg.op_queue.length == 0) 
					{
						if (toInsert.length == 0)
						{
							if (needFinDelMin)
							{
								needFinDelMin = false;
								svg.nextX = getFirstX(0);
								thickHeap.getNewMin();
								return;
							}
							else
							{
								isanim = false;
								ismoving = false;
								hideSpans();
								res.textContent = result;
								setOp("---------------------------------------------------------------------------");
								return;
							}
						}
						var node = toInsert.shift();
						svg.moveNodes = [];
						while (toMove.length && toMove[0].rank >= node.rank)
						{
							var curnode = toMove.shift();
							var obj = {};
							var cor = svg.getNodeCoords(curnode.index);

							obj.moveFunc = svg.moveFull;
							obj.node = curnode;
							obj.x = cor.x;;
							obj.y = cor.y;
							obj.stopx = cor.x - delta;
							obj.stopy = cor.y;
							svg.activateNode(curnode.index);
							svg.moveNodes.push(obj);
						}
						svg.op_queue.push({op:"movetopos", args:[node]});
						if (svg.moveNodes.length > 0)
						{
							//alert(2);
							svg.moveStep();
							return;
						}
					}
					var op = svg.op_queue.shift();
					
					// description
					if (op.op == "fastening")
					{
						var s = [op.args[0], op.args[1], op.args[2]]; 
						var f = [op.args[3], op.args[4], op.args[5]]; 

						var cor = [];
						
						for (var i = 0; i < 3; ++i)
						{
							svg.activateNode(s[i].index);
							cor.push(svg.getNodeCoords(s[i].index));								
						}
						svg.moveNodes = [];
						for (var i = 0; i < 3; i++)
						{
							var obj = {};
							obj.node = s[i];
							obj.x = cor[i].x;
							obj.y = cor[i].y;
							obj.moveFunc = svg.moveTreeFast;
							if (s[i] == f[2])
							{
								obj.stopx = cor[2].x;
								obj.stopy = cor[2].y;
								if (s[i].rank == 1)
								{	
									obj.stopx = cor[1].x;
								}
								svg.moveNodes[2] = obj;
							}
							else if (s[i] == f[1])
							{
								obj.stopx = cor[1].x;
								obj.stopy = cor[1].y + svg.VER_DIST;
								svg.moveNodes[1] = obj;
							}
							else if (s[i] == f[0])
							{
								obj.stopx = cor[0].x;
								obj.stopy = cor[0].y + svg.VER_DIST;								
								svg.moveNodes[0] = obj;
							}
						}
						setOp("Связывание трёх деревьев ранга " + f[0].rank + " в дерево ранга " + (f[0].rank + 1));
						svg.moveStep();
					}
					
					else if (op.op == "leftadded")
					{
						svg.moveNodes = [];
						svg.nextX -= svg.HOR_DIST;
						var node = op.args[0];
						var cor = svg.getNodeCoords(node.index);
						svg.activateNode(node.index);
						var obj = {};
						
						obj.moveFunc = svg.moveTreeFast;
						obj.node = node;
						obj.x = cor.x;;
						obj.y = cor.y;
						obj.stopx = cor.x - svg.HOR_DIST;
						obj.stopy = cor.y;
						svg.moveNodes = [];
						svg.moveNodes[0] = obj;
						svg.moveStep();
					}
					
					else if (op.op == "addright")
					{
						var node1 = op.args[0], node2 = op.args[1];
						node1.righte = svg.createEdge(node1.index, node2.index, false);
						var ind = node1.righte;
						svg.activateEdge(ind);
						svg.opacityStep(ind, false, false, svg.nextAnimation);
					}
					
					else if (op.op == "deleteright")
					{
						var p1 = op.args[0], p2 = op.args[1], p3 = op.args[2];
						svg.opacityStep(p1.righte, false, true, null);
						svg.opacityStep(p2.righte, false, true, svg.nextAnimation);
						p1.righte = null;
						p2.righte = null;
						p3.righte = null;
					}
					
					// description
					else if (op.op == "opacityNode")
					{
						var node1 = op.args[0];
						svg.opacityStep(node1.index, true, false, svg.nextAnimation);
						setOp("Вставка нового дерева ранга 0 в кучу.");
					}
					
					else if (op.op == "deactivatenodes")
					{
						for (var i = 0; i < op.args.length; i++)
						{
							svg.deactivateNode(op.args[i].index);							
						}
						svg.nextAnimation();
					}
					
					// description
					else if (op.op == "changemin")
					{
						var pr = op.args[0], cur = op.args[1];
						if (pr != null)
						{
							//svg.nodes_[pr.index].firstChild.style['transition-duration'] = "1s";
							svg.nodes_[pr.index].firstChild.classList.remove("minNode");			
						}
						//svg.nodes_[cur.index].firstChild.style['transition-duration'] = "1s";	
						svg.nodes_[cur.index].firstChild.classList.add("minNode");	
						/*setTimeout(function() {
							if (pr != null) svg.nodes_[pr.index].firstChild.style['transition-duration'] = "0s";
							svg.nodes_[cur.index].firstChild.style['transition-duration'] = "0s";	
						}, 10000);*/
						setTimeout(svg.nextAnimation, 1000);
						setOp("Обновление минимального узла.");
					}
					
					// description
					else if (op.op == "setdeleted")
					{
						var node = op.args[0];
						var leftn = op.args[1];
						svg.nodes_[node.index].firstChild.classList.add("deletedNode");
						if (node.righte != null && leftn != null)
						{
							svg.opacityStep(node.righte, false, true, null);
							svg.opacityStep(leftn.righte, false, true, svg.nextAnimation);
						}
						else if(node.righte != null)
						{
							svg.opacityStep(node.righte, false, true, svg.nextAnimation);
						}
						else if(leftn != null)
						{
							svg.opacityStep(leftn.righte, false, true, svg.nextAnimation);
						}
						else svg.nextAnimation();
						setOp("Удаление дерева ранга " + node.rank + " из списка деревьев.")
					}
					
					else if (op.op == "movedown")
					{
						//alert(1);
						var deltay = op.args[0].rank * svg.VER_DIST;
						svg.moveNodes = []; 
						for (var i = 0; i < op.args.length; i++)
						{
							var curnode = op.args[i];
							var obj = {};
							var cor = svg.getNodeCoords(curnode.index);

							obj.moveFunc = svg.moveTreeToDel;
							obj.node = curnode;
							obj.x = cor.x;;
							obj.y = cor.y;
							obj.stopx = cor.x;
							obj.stopy = cor.y + deltay;
							svg.moveNodes.push(obj);
						}
						svg.activateNode(op.args[0].index);
						svg.moveStep()
					}
					
					// description
					else if (op.op == "deletenode")
					{
						if (op.args.length == 1)
						{
							svg.opacityStep(op.args[0].index, true, true, svg.nextAnimation);
							return;
						}
						else
						{
							svg.opacityStep(op.args[0].index, true, true, null);
						}
						for (var i = 1; i < op.args.length - 1; i++)
						{
							var node = op.args[i];
							svg.opacityStep(node.tope, false, true, null);
							if (node.righte != null)
							{
								svg.opacityStep(node.righte, false, true, null);
							}
							node.tope = null;
							node.righte = null;
						}
						var node = op.args[i];
						svg.opacityStep(node.tope, false, true, svg.nextAnimation);
						if (node.righte != null)
						{
							svg.opacityStep(node.righte, false, true, null);
						}
						node.tope = null;
						node.righte = null;
						setOp("Удаление связей с детьми и связей между детьми удаленной вершины.");
					}
					
					// desc
					else if (op.op == "moverightpart")
					{
						//alert(1);
						var node = op.args[0];
						var obj = {};
						var cor = svg.getNodeCoords(node.index);
						svg.activateNode(node.index);
						svg.moveNodes = [];
						obj.moveFunc = svg.moveFull;
						obj.node = node;
						obj.x = cor.x;;
						obj.y = cor.y;
						obj.stopx = cor.x - delta;
						obj.stopy = cor.y;
						svg.moveNodes.push(obj);
						svg.moveStep();
						setOp("Восстановление списочной части ранга " + node.rank + ".");
					}
					
					//desc
					else if (op.op == "movetopos")
					{
						//alert(1);
						var node = op.args[0];
						var newx = getFirstX(node.rank);
						newx += (getDelta(node.rank) - svg.HOR_DIST);
						var obj = {};
						var cor = svg.getNodeCoords(node.index);
						
						svg.activateNode(node.index);
						svg.moveNodes = [];
						obj.moveFunc = svg.moveFull;
						obj.node = node;
						obj.x = cor.x;;
						obj.y = cor.y;
						obj.stopx = newx;
						obj.stopy = svg.START_Y;
						svg.moveNodes.push(obj);
						delta -= getDelta(node.rank);
						svg.op_queue.push({op:"insertTree", args:[node]});
						svg.moveStep();
						setOp("Вставка сына удаленной вершины ранга " + node.rank + " в кучу.");
					}
					
					else if (op.op == "insertTree")
					{
						thickHeap._insertTree(op.args[0], true);
					}
					
					// description
					else if (op.op == "addedges")
					{
						var n1 = op.args[0];
						var n2 = op.args[1];
						var n3 = op.args[2];
						n1.tope = svg.createEdge(n1.index, n3.index, true);
						n2.tope = svg.createEdge(n2.index, n3.index, false);
						n1.righte = svg.createEdge(n1.index, n2.index, true);
						if (n2.right != null)
						{
							var plc = n2.right; //prev left child
							n2.righte = svg.createEdge(n2.index, plc.index, true);
							svg.opacityStep(n2.righte, false, false, null);
							svg.opacityStep(plc.tope, false, true, null);
							plc.tope = svg.createEdge(plc.index, n3.index, false);
							svg.opacityStep(plc.tope, false, false, null);
						}
						svg.opacityStep(n1.tope, false, false, null);
						svg.opacityStep(n1.righte, false, false, null);
						svg.opacityStep(n2.tope, false, false, svg.nextAnimation);
						svg.op_queue.unshift({op:"deactivatenodes", args:[n1, n2, n3]});
						setOp("Обновление ссылок.");
					}
					
					//description
					else if (op.op == "movetop")
					{
						var node = op.args[0];
						var ind = svg.createNode(node.value);
						svg.nextX -= svg.HOR_DIST;
						svg.nodes_[ind].firstChild.classList.add("minNode");
						var mincor = svg.getNodeCoords(node.index);
						svg.setNodeCoords(ind, mincor.x, mincor.y);
						svg.nodes_[ind].style.opacity = 1;
						svg.moveNodes = [];
						var obj = {};
						obj.moveFunc = svg.moveFull;
						obj.node = new Node(node.value, ind);
						obj.x = mincor.x;;
						obj.y = mincor.y;
						obj.stopx = mincor.x;
						obj.stopy =mincor.y - 2*svg.HOR_DIST;
						svg.moveNodes.push(obj);
						svg.opacityStep(ind, true, true, null);
						svg.moveStep();
						setOp("Получение значения минимального узла.")
					}
					
					else if (op.op == "activatenode")
					{
						var node = op.args[0];
						svg.activateNode(node.index);
						setTimeout(svg.deactivateNode, 1000, node.index);
						setTimeout(svg.nextAnimation, 1001);
					}
					
					// description
					else if (op.op == "increaserank")
					{
						//alert(2);
						var ind = svg.increaseRank();
						svg.moveNodes = [];
						for (var i = ind - 1; i >=0; i--)
						{
							var obj = {};
							obj.moveFunc = svg.moveRoot;
							obj.node = svg.rootnodes_[i];
							var cor = svg.getRootCoords(i);
							obj.x = cor.x;;
							obj.y = cor.y;
							obj.stopx = cor.x + 25;
							obj.stopy = cor.y;
							svg.moveNodes.push(obj);
						}
						svg.moveStep();
						svg.op_queue.unshift({op:"showroot", args:[]});
						setOp("Добавление нового разряда в корневой счетчик.");
					}
					
					else if (op.op == "showroot")
					{
						//alert(1);
						svg.rootnodes_[svg.nextRank - 1].style['transition-duration'] = ".5s";
						svg.rootnodes_[svg.nextRank - 1].style.opacity = 1;
						svg.nextAnimation();
					}
					
					// description
					else if (op.op == "setrootval")
					{
						svg.setRootVal(op.args[0], op.args[1]);
						setOp("Изменение значения " + op.args[0] + "-го разряда корневого счетчика на " + op.args[1] + ".");
					}
				}				
			}
		</script>
		<script>			
			function Node(value, index)
			{
				this.value = value;
				this.parent = null;
				this.left = null;
				this.right = null;
				this.leftChild = null;
				this.rank = 0;
				this.index = index;//VISUALISATION
				this.righte;//VISUALISATION
				this.tope;//VISUALISATION
			}
			
			function RootCounterNode()
			{
				this.value = 0;
				this.listPointer = null;
			}
			
			function ThickHeap()
			{
				// PRIVATE
				this._INF = 1000000100;
				this._size = 0;
				this._maxRank = -1;
				this._minNode = null;
				this._rootCounter  = [];
				
				this.getMaxRank = function()
				{
					for (var i = this._maxRank; i>=0; i--)
					{
						if (this._rootCounter[i].value == 3) return i + 1;
						if (this._rootCounter[i].value > 0) return i;
						
					}
					return 0;
				}
				
				// Вставляет дерево ранга k в список деревьев k-го элемента корневого счетчика
				this._insertTreeInList = function(tree)
				{
					if (tree.rank > this._maxRank || this._rootCounter[tree.rank].value == 3)
					{
						throw "insertTreeInList error";					
					}
					
					if (this._rootCounter[tree.rank].listPointer == null)
					{
						this._rootCounter[tree.rank].listPointer = tree;
						return;
					}
					
					var cur = this._rootCounter[tree.rank].listPointer;
					
					while (cur.right != null)
					{
						cur = cur.right;
					}
					cur.right = tree;	
				}
				
				// Удаляет дерево ранга k из списка деревьев k-го элемента корневого счетчика
				this._deleteTreeFromList = function(tree)
				{
					var rank = tree.rank;
					if (rank > this._maxRank)
					{
						throw "deleteTreeFromList error";
					}
					var currentPointer = this._rootCounter[rank].listPointer;
					if (currentPointer == tree)
					{
						this._rootCounter[rank].listPointer = tree.right;
						tree.right = null;
						return;
					}
					while (currentPointer.right != tree)
					{
						currentPointer = currentPointer.right;
					}
					currentPointer.right = tree.right;
					tree.right = null;
				}
				
				// Возвращает указатель на минималный узел списочной части корневого счетчика
				this._getMinFromList = function(listPointer)
				{
					var curp = listPointer;
					while (curp != null) 
					{
						svg.op_queue.push({op:"activatenode", args:[curp]});
						if (this._getKey(curp) < this._getKey(this._minNode))
						{
							svg.op_queue.push({op:"changemin", args:[this._minNode, curp]});							
							this._minNode = curp;
						}
						curp = curp.right;
					}
				}
				
				// Связывает три толстых дерева ранга k в одно дерево ранга k + 1
				this._fastening = function(p1, p2, p3)
				{
					svg.op_queue.push({op:"deleteright", args:[p1, p2, p3]}); // VISUALIZATION
					var svg1 = p1, svg2 = p2, svg3 = p3; // VISUALIZATION
					var minp;
					// Если узел явлеятся minNode, он должен быть в корне
					var foundmin = false;
					if (p1.rank == this._minNode.rank)
					{
						if (p1 == this._minNode)
						{
							minp = p1;
							p1 = p3;
							foundmin = true;
						}
						else if (p2 == this._minNode)
						{
							minp = p2;
							p2 = p3;
							foundmin = true;
						}
						else if (p3 == this._minNode)
						{
							minp = p3;
							foundmin = true;
						}
					}

					if (!foundmin)
					{
						if (p1.value <= p2.value && p1.value <= p3.value)
						{
							minp = p1;
							p1 = p3;
						}
						else if (p2.value <= p3.value && p2.value <= p1.value)
						{
							minp = p2;
							p2 = p3;
						}
						else if (p3.value <= p2.value && p3.value <= p1.value)
						{
							minp = p3;
						}
					}
					
					
					// как были с лева на право, как стали с лева на право
					svg.op_queue.push({op:"fastening", args:[svg1, svg2, svg3, p1, p2, minp]}); // VISUALIZATION

					p1.left = null;
					p1.right = p2;
					p1.parent = minp;
					p2.left = p1;
					p2.right = minp.leftChild;
					p2.parent = minp;
					if (minp.leftChild != null)
					{
						minp.leftChild.left = p2;
					}
					
					minp.leftChild = p1;
					minp.left = null;
					minp.right = null;
					minp.parent = null;
					minp.rank++;
					return minp;
				}
				
				// Связывает 3 дерева ранга k в одно дерево ранга k + 1, поддерживая корневой счетчик [операция фиксации]
				this._fixRootNode = function(rank)
				{
					if (rank > this._maxRank || this._rootCounter[rank].value != 3)
					{
						throw "fixRootNode error";
					}

					this._rootCounter[rank].value = 0;
					svg.op_queue.push({op:"setrootval", args:[rank, 1]});
					var p1 = this._rootCounter[rank].listPointer;
					var p2 = p1.right;
					var p3 = p2.right;
					p1.right = p2.right = null;
					var newp = this._fastening(p1, p2, p3);
					this._rootCounter[rank].listPointer = null;
					this._insertTree(newp);
				}
				
				// Вставка дерева в кучу
				this._insertTree = function(tree, needanim)
				{
					var rank = tree.rank;
					var wasvalue = this._maxRank >= rank ? this._rootCounter[rank].value : 0;
					if (rank > this._maxRank + 1)
					{
						throw "insertTree error";
					}

					if (rank == this._maxRank + 1)
					{
						this._increaseMaxRank();
					}

					var isfix = false;
					// Если вставить не можем, освобождаем место
					if (this._rootCounter[rank].value == 3)
					{
						isfix = true;
						this._fixRootNode(rank);
					}
					//VISUALIZATION
					else if (this._rootCounter[rank].value == 1)
					{
						svg.op_queue.push({op:"addright", args:[this._rootCounter[rank].listPointer, tree]});
					}
					else if (this._rootCounter[rank].value == 2)
					{
						svg.op_queue.push({op:"addright", args:[this._rootCounter[rank].listPointer.right, tree]});
					}
					
					
					this._insertTreeInList(tree);
					this._rootCounter[rank].value++;					
					if (!isfix) svg.op_queue.push({op:"setrootval", args:[rank, this._rootCounter[rank].value]});
					if (needanim == true && tree.rank == 0 && wasvalue == 3 && this._rootCounter[0].value == 1 && this._maxRank > 0)
					{
						svg.op_queue.push({op:"leftadded", args:[tree]}); // VISUALIZATION
					}
					if (needanim == true)
					{
						svg.nextAnimation();
					}
				}
				
				// Удаление дерева из кучи
				this._deleteTree = function(tree)
				{
					if (tree.rank > this._maxRank || this._rootCounter[tree.rank].value == 0)
					{
						throw "deleteTree error";
					}

					this._deleteTreeFromList(tree);
					this._rootCounter[tree.rank].value--;					
					svg.op_queue.push({op:"setrootval", args:[tree.rank, this._rootCounter[tree.rank].value]});
				}
				
				// Возвращает указатель на минимальный узел среди корневых узлов
				this._setMinNodeInRoot = function()
				{
					this._minNode = null;
					for (var i = this._maxRank; i >= 0; --i)
					{
						this._getMinFromList(this._rootCounter[i].listPointer);
					}
				}
				
				// Увеличивает значение maxRank, добавляя узлы в соотв. счетчики
				this._increaseMaxRank = function()
				{
					this._maxRank++;
					svg.op_queue.push({op:"increaserank", args:[]});
					this._rootCounter.push(new RootCounterNode());
				}
				
				// Возвращает значение узла, либо +inf, если узел null
				this._getKey = function(p)
				{
					if (p == null)
					{
						return this._INF;
					}
					else
					{
						return p.value;
					}
				}
				
				// PUBLIC
				this.insert = function(value)
				{
					var wasvalue = this._maxRank >= 0 ? this._rootCounter[0].value : 0;
					var newIndex = svg.createNode(value); //VISUALISATION
					this._size++;
					var newNode = new Node(value, newIndex); //VISUALISATION
					
					svg.op_queue.push({op:"opacityNode", args:[newNode]}); // VISUALIZATION
					
					var prevMin;
					if (this._getKey(newNode) < this._getKey(this._minNode))
					{
						prevMin = this._minNode;
						this._minNode = newNode;
					}
					this._insertTree(newNode);
					
					//VISUALIZATION
					if (wasvalue == 3 && this._rootCounter[0].value == 1 && this._maxRank > 0)
					{
						svg.op_queue.push({op:"leftadded", args:[newNode]}); // VISUALIZATION
					}
					
					// VISUALIZATION
					if (this._minNode == newNode)
					{
						svg.op_queue.push({op:"changemin", args:[prevMin, newNode]}); // VISUALIZATION
					}
				}

				this.getMin = function()
				{
					if (this._minNode == null)
					{
						throw "Error. Heap is empty.";
					}
					svg.op_queue.push({op:"movetop", args:[this._minNode]});
					return this._minNode.value;
				}

				this.deleteMin = function()
				{
					if (this._minNode == null)
					{
						throw "Error. Heap is empty.";
					}
					this._size--;
					
					//VISUAL
					delta = getDelta(this._minNode.rank);
					var args = [];
					args.push(this._minNode);
					var minLeft = this._rootCounter[this._minNode.rank].listPointer;
					if (minLeft == this._minNode) minLeft = null;
					else 
					{
						while(minLeft.right != this._minNode) minLeft = minLeft.right;
					}
					
					for (var rank = this._minNode.rank - 1; rank >= 0; rank--)
					{
						if (this._rootCounter[rank].listPointer != null)
						{
							toMove.push(this._rootCounter[rank].listPointer);
						}
					}
					
					var cur = this._minNode.leftChild;
					
					var cur1 = this._minNode.leftChild; // VIS
					this._minNode.leftChild = null; // VIS
					//VISUAL
					while (cur1 != null)
					{
						args.push(cur1);
						cur1 = cur1.right;
					}
					svg.op_queue.push({op:"setdeleted", args:[this._minNode, minLeft]});//VISUALIZATION
					svg.op_queue.push({op:"movedown", args:args}); // VISUALIZATION
					svg.op_queue.push({op:"deletenode", args:args}); // VISUALIZATION
					if (this._minNode.right != null)
						svg.op_queue.push({op:"moverightpart", args:[this._minNode.right]}); // VISUALIZATION
					if (minLeft != null && this._minNode.right != null)
					{
						svg.op_queue.push({op:"addright", args:[minLeft, this._minNode.right]}); // VISUALIZATION
					}
					
					while (cur != null)
					{
						var temp = cur;
						cur = cur.right;
						temp.left = null;
						temp.right = null;
						temp.parent = null;
						toInsert.push(temp);
						//this._insertTree(temp);
					}
					needFinDelMin = true;
					this._deleteTree(this._minNode);
					var minValue = this._minNode.value;
					return minValue;
				}
				
				this.getNewMin = function()
				{
					this._setMinNodeInRoot();
					svg.nextAnimation();
				}

				this.getSize = function()
				{
					return this._size;
				}

				this.isEmpty = function()
				{
					return this._size == 0;
				}
			}
			
			var thickHeap = new ThickHeap();
		
			function hideSpans()
			{
				sp1.style.opacity = 0;
				sp2.style.opacity = 0;
				sp3.style.opacity = 0;
				sp4.style.opacity = 0;
				sp5.style.opacity = 0;
				sp6.style.opacity = 0;
				sp7.style.opacity = 0;
			}
			
			function showSpan(sp, msg)
			{
				sp.textContent = msg;
				sp.style.opacity = 1;
			}
			
			function check(val)
			{
				if (val == "") return false;
				for (var i = 0; i < val.length; ++i)
				{
					if (val[i] == '.' || val[i] == ',') return false;
				}
				var ans = +val;
				if (isNaN(ans)) return false;
				return true;
			}
			
			function insert_click()
			{
				hideSpans();
				if (isanim)
				{
					showSpan(sp1, "Дождитесь окончания операции.");
					return;
				}
				
				var val = ins.value;
				if (check(val) == false)
				{
					showSpan(sp1, "Введите целое число от -99 до 999");
					return;
				}
				
				res.textContent = "-";
				thickHeap.insert(+val);
				isanim = true;
				if (isauto) svg.nextAnimation();
				result = "OK";
			}
			
			function insertrand_click()
			{
				hideSpans();
				if (isanim)
				{
					showSpan(sp5, "Дождитесь окончания операции.");
					return;
				}
				
				val = 999 - Math.floor(1098 * Math.random());
				
				res.textContent = "-";
				thickHeap.insert(val);
				isanim = true;
				if (isauto) svg.nextAnimation();
				result = "OK";
			}
			
			function deleteMin_click()
			{		
				hideSpans();
				if (isanim)
				{
					showSpan(sp3, "Дождитесь окончания операции.");
					return;
				}
				if (thickHeap.isEmpty())
				{
					showSpan(sp3, "В куче нет элементов.");
					return;
				}
				
				res.textContent = "-";
				result = thickHeap._minNode.value;
				thickHeap.deleteMin();
				isanim = true;
				svg.nextAnimation();
			}
			
			function getMin_click()
			{
				hideSpans();
				if (isanim)
				{
					showSpan(sp2, "Дождитесь окончания операции.");
					return;
				}
				if (thickHeap.isEmpty())
				{
					showSpan(sp2, "В куче нет элементов.");
					return;
				}
				
				res.textContent = "-";
				var val = thickHeap.getMin();
				isanim = true;
				svg.nextAnimation();
				result = val;
			}
			function size_click()
			{
				hideSpans();
				if (isanim)
				{
					showSpan(sp4, "Дождитесь окончания операции.");
					return;
				}
				
				var val = thickHeap.getSize();
				res.textContent = val;
			}
			
			function speedChange()
			{
				speedsp.textContent = speed.value;
				svg.DELAY = 25 - speed.value;
			}
			
			function setOp(op)
			{
				var newSp = d.createElement("span");
				newSp.classList.add("operation");
				newSp.textContent = op;
				if (oper.children.length == 0)
				{
					oper.appendChild(newSp);
				}
				else
				{
					oper.insertBefore(d.createElement('br'), oper.firstChild);
					oper.insertBefore(newSp, oper.firstChild);
				}
			}
			
			function changeMode()
			{
				hideSpans();
				// пошаговый выключили
				if (mode.checked == false)
				{
					if (isanim)
					{
						mode.checked = true;
						showSpan(sp7, "Дождитесь окончания операции.");
						return;
					}
					else
					{
						isauto = true;
						nextstep.setAttribute("disabled", "disabled");
					}
				}
				else
				{
					if (isanim)
					{
						mode.checked = false;
						showSpan(sp7, "Дождитесь окончания операции.");
						return;
					}
					else
					{
						isauto = false;
						nextstep.removeAttribute("disabled");
					}
				}
			}
			
			function nextStep()
			{
				hideSpans();
				if (isanim == false)
				{
					showSpan(sp6, "Сначала выберите операцию.");
					return;
				}
				if (ismoving)
				{
					showSpan(sp6, "Дождитесь окончания анимации.");
					return;
				}
				else
				{
					issecond = false;
					svg.nextAnimation();
				}
			}
			
		</script>
		<svg id = "layout" width = "1090" height = "480" onload = "svg.layout_ = this;">
			<defs>
				<marker id="end-arrow" viewBox="0 -5 10 10" refX="33" markerWidth="3.5" markerHeight="3.5" orient="auto">
					<path d="M0,-5L10,0L0,5"></path>
				</marker>
				<marker id="start-arrow" viewBox="0 -5 10 10" refX="33" markerWidth="3.5" markerHeight="3.5" orient="auto-start-reverse">
					<path d="M0,-5L10,0L0,5"></path>
				</marker>
				<marker id="mark-end-arrow" viewBox="0 -5 10 10" refX="7" markerWidth="3.5" markerHeight="3.5" orient="auto">		<path d="M0,-5L10,0L0,5"></path>
				</marker>
			</defs>
			<!--text x=10 y=37 font-family="sans-serif" style="font-size:17px" >Корневой</text>
			<text x=10 y=56 font-family="sans-serif" style="font-size:17px" >счетчик:</text-->
			<g transform="translate(450,28)" style="opacity: 1;">
				<circle class="node minNode" r="17"></circle>
			</g>
			<g transform="translate(750,28)" style="opacity: 1;">
				<circle class="node activeNode" r="17"></circle>
			</g>
			<text x=478 y=33 font-family="sans-serif" style="font-size:15px" >- минимальный узел в куче </text>
			<text x=778 y=33 font-family="sans-serif" style="font-size:15px" >- активный узел </text>
			<text x=50 y=22 font-family="sans-serif" style="font-size:15px" >ранг </text>
			<text x=15 y=46 font-family="sans-serif" style="font-size:15px" >значение </text>
			<!--text x=10 y=70 font-family="sans-serif" style="font-size:15px" >указатель </text-->
		
		</svg>
		<div class="rightblock">
			<input maxlength="3" onfocus = "hideSpans();" id="ins" type="text">
			<button style="width:189px" onclick = "insert_click()">Добавить элемент</button><br>
			<span class="error" id="sp1" style="opacity:0">hh</span><br>
			<button style="width:100%" onclick = "insertrand_click()">Добавить случайный элемент</button><br>
			<span class="error" id="sp5" style="opacity:0">gg</span><br>
			<button style="width:100%" onclick = "getMin_click()">Получить минимальный элемент</button><br>
			<span class="error" id="sp2" style="opacity:0">gg</span><br>
			<button style="width:100%" onclick = "deleteMin_click()">Удалить минимальный элемент</button><br>
			<span class="error" id="sp3" style="opacity:0">gg</span><br>
			<button style="width:100%" onclick = "size_click()">Количество элементов</button><br>
			<span class="error" id="sp4" style="opacity:0">gg</span><br>
			<input id="mode" onchange = "changeMode()" type="checkbox" >
			<span style="vertical-align:top; font-size:17px; display:inline-block; margin:0px 10px 0 0;">Пошаговый режим</span>
			<br>
			<span class="error" id="sp7" style="opacity:0">gg</span><br>			
			<button onclick = "nextStep()" id="nextstep" disabled>Следущий шаг</button><br>
			<span class="error" id="sp6" style="opacity:0">gg</span><br>
			<span style="vertical-align:top; font-size:17px; display:inline-block; margin:2px 10px 0 0;">Скорость:   </span>
			<input id="speed" oninput="speedChange()" style="width:110px;" type="range" min="1" max="25" value="15">
			<span id="speedsp" style="vertical-align:top; display:inline-block; margin:3px 0 0 10px;">15</span><br><br>
			<span style="font-size:20px;" >Результат операции:  </span>
			<b><span id="res" class="result">-</span></b><br><br>
			
		</div>
		<br>

		<span class="curop">Список операций: </span>
		<div id = "oper">
				
		</div>
	</body>
</html>